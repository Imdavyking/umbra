pragma language_version >= 0.14.0;

import CompactStandardLibrary;

export { Maybe };
export { CoinInfo ,QualifiedCoinInfo};
export { ZswapCoinPublicKey };
export { Certificate };


// ─────────────────────────────────────────────────────────────────────────────
// Types & Enums
// ─────────────────────────────────────────────────────────────────────────────

export enum STATUS { Pending, Verified, Revoked };

struct Certificate {
  issuer: ZswapCoinPublicKey,
  issued_at: Uint<64>,
  valid_until: Uint<64>,
  is_valid: Boolean,
  owner: ZswapCoinPublicKey,
  year_of_birth: Uint<16>
}

struct Feature {
  creator: ZswapCoinPublicKey, // Creator of the feature
  name: Opaque<"string">,        // Feature title
  description: Opaque<"string">, // Short text describing the feature
  category: Opaque<"string">,    // Type/category of feature (e.g., "game", "content", "service")
  image_url: Opaque<"string">,   // Optional image/logo for frontend display
  min_age: Uint<16>,             // Age requirement
  price: Uint<64>,               // Optional: token/coin cost to access
  created_at: Uint<64>,          // Timestamp for creation
  is_active: Boolean,            // If feature is currently active,
  coin_type: Bytes<32> // type of coin required for payment
}

struct VoteTally {
  up: Uint<64>,
  down: Uint<64>
}

// ─────────────────────────────────────────────────────────────────────────────
// Witnesses (ZK-friendly helpers)
// ─────────────────────────────────────────────────────────────────────────────

// User creates the cert privately from their local data
witness user_certificate(
  issuer: ZswapCoinPublicKey,
  issued_at: Uint<64>,
  valid_until: Uint<64>,
  is_valid: Boolean,
  owner: ZswapCoinPublicKey,
  year_of_birth: Uint<16>
): Certificate;

// Proves (in zero-knowledge) that:
//  • the certificate is correctly signed by its issuer over canonical fields
//  • is_valid == true and now() < valid_until
//  • owner == ownPublicKey()
witness prove_cert_signed_and_fresh(cert: Certificate): Boolean;

// Proves age requirement without revealing DOB/age
witness check_age_feature(
  cert: Certificate,
  feature_age: Uint<16>
): Boolean;

// Derives a privacy-preserving, deterministic nullifier for (cert, feature_id)
// Used to mark anonymous access without linking the owner.
// Must be stable for the same (cert, feature_id).
witness gen_access_nullifier(
  cert: Certificate,
  feature_id: Uint<64>
): Uint<128>;

// Derives a one-vote-only, anonymous nullifier for (cert, feature_id).
// salt is caller-provided to avoid correlation across apps while
// staying deterministic for double-vote prevention.
witness gen_vote_nullifier(
  cert: Certificate,
  feature_id: Uint<64>,
  salt: Bytes<32>
): Uint<128>;

// ─────────────────────────────────────────────────────────────────────────────
export sealed ledger admin: ZswapCoinPublicKey;

export ledger feature_balances:  Map<Uint<64>, Uint<128>>; // Coin type → total balance

// Trusted issuers list (admin-managed)
export ledger trusted_issuers: Map<ZswapCoinPublicKey, Boolean>;

// Certificate hash → status
export ledger registered_hashes: Map<Bytes<32>, STATUS>;

export ledger protocolTVL: Map<Bytes<32>, QualifiedCoinInfo>;

// Owner pubkey → certificate hash (one per owner)
export ledger certificate_owners: Map<ZswapCoinPublicKey, Bytes<32>>;

// Feature catalog
export ledger features: Map<Uint<64>, Feature>;
export ledger feature_counter: Counter;

// Anonymous access records (set via nullifiers)
export ledger access_nullifiers: Map<Uint<128>, Boolean>;

// Anonymous vote deduplication (one nullifier per user per feature)
export ledger vote_nullifiers: Map<Uint<128>, Boolean>;

// Feature vote tallies (public aggregate only)
export ledger feature_vote_tallies: Map<Uint<64>, VoteTally>;

// Optional usage flag (anonymous success; can be omitted if not needed)
export ledger verified_users: Map<ZswapCoinPublicKey, Boolean>;

// ─────────────────────────────────────────────────────────────────────────────
// Constructor
// ─────────────────────────────────────────────────────────────────────────────

constructor() {
  admin = ownPublicKey();
}

// ─────────────────────────────────────────────────────────────────────────────
// Utilities
// ─────────────────────────────────────────────────────────────────────────────

export circuit cert_hash(cert: Certificate): Bytes<32> {
  return persistentHash<Certificate>(cert);
}

// ─────────────────────────────────────────────────────────────────────────────
// Admin: Manage trusted issuers
// ─────────────────────────────────────────────────────────────────────────────

export circuit add_trusted_issuer(issuer: ZswapCoinPublicKey): [] {
  assert(ownPublicKey() == admin, "Only admin");
  trusted_issuers.insert(disclose(issuer), true);
}

export circuit remove_trusted_issuer(issuer: ZswapCoinPublicKey): [] {
  assert(ownPublicKey() == admin, "Only admin");
  trusted_issuers.remove(disclose(issuer));
}

// ─────────────────────────────────────────────────────────────────────────────
// ZK-native certificate registration (auto-verify)
// ─────────────────────────────────────────────────────────────────────────────

export circuit register(
  issuer: ZswapCoinPublicKey,
  issued_at: Uint<64>,
  valid_until: Uint<64>,
  is_valid: Boolean,
  year_of_birth: Uint<16>
): [] {
  // Build private cert bound to caller
  const cert = user_certificate(
    issuer,
    issued_at,
    valid_until,
    is_valid,
    ownPublicKey(),
    year_of_birth
  );

// Issuer must be trusted (public check) NOTE: for now we assume issuer is trusted
// const issuerKey = disclose(cert.issuer);
// assert(trusted_issuers.member(issuerKey), "Untrusted issuer");

// ZK proof: signature, freshness, ownership
  const proofOk = disclose(prove_cert_signed_and_fresh(cert));
  assert(proofOk, "Invalid or expired certificate");

    // One cert per owner :NOTE: for now we allow user to re-register
    const caller = ownPublicKey();
    // assert(!certificate_owners.member(caller), "Certificate already registered for owner");

  // Commit only the hash on-chain
  const hash = disclose(cert_hash(cert));
  assert(!registered_hashes.member(hash), "Duplicate certificate hash");

  // Auto-verify on successful proof
  registered_hashes.insert(hash, STATUS.Verified);
  // Track ownership
  certificate_owners.insert(caller,hash);
}



// ─────────────────────────────────────────────────────────────────────────────
// Admin: verify multiple certificate hashes off-chain
// ─────────────────────────────────────────────────────────────────────────────
export circuit verify_certificates(hashes: Vector<10, Maybe<Bytes<32>>>): [] {
    assert(admin == ownPublicKey(), "Not admin"); 
    for (const maybe_hash of hashes) {
        if (disclose(maybe_hash.is_some)) {
            const hash_value = disclose(maybe_hash.value);
            registered_hashes.insert(hash_value, STATUS.Verified);
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Verification check (works with zk flow)
// ─────────────────────────────────────────────────────────────────────────────

export circuit check_verification(cert: Certificate): [] {
  const hash = disclose(cert_hash(cert));
  assert(registered_hashes.member(hash), "Certificate not registered");
  assert(registered_hashes.lookup(hash) == STATUS.Verified, "Certificate not verified");
}

// ─────────────────────────────────────────────────────────────────────────────
// Features
// ─────────────────────────────────────────────────────────────────────────────

export circuit create_feature(
  feature_name: Opaque<"string">,
  min_age: Uint<16>,
  description: Opaque<"string">,
  category: Opaque<"string">,
  image_url: Opaque<"string">,
  price: Uint<64>,
  created_at: Uint<64>,
  coin_type: Bytes<32>
): [] {
  const feature_id = feature_counter;
  features.insert(
    feature_id,
    Feature{
      ...default<Feature>,
      creator: ownPublicKey(),
      name: disclose(feature_name),
      min_age: disclose(min_age),
      description: disclose(description),
      category: disclose(category),
      image_url: disclose(image_url),
      price: disclose(price),
      created_at: disclose(created_at),
      coin_type: disclose(coin_type),
      is_active: true
    }
  );

  // Initialize vote tally
  feature_vote_tallies.insert(
    feature_id,
    VoteTally{ ...default<VoteTally>, up: 0, down: 0 }
  );

  feature_counter.increment(1);
}

// Access a private feature with age gating and verified cert
// Records an anonymous access nullifier to allow later voting.
export circuit access_private_feature(
  cert: Certificate,
  feature_id: Uint<64>,
  payment: CoinInfo // The coin/token the user sends to access the feature
): [] {
  // Certificate must be registered & Verified
  const hash = disclose(cert_hash(cert));
  assert(registered_hashes.member(hash), "Certificate not registered");
  assert(registered_hashes.lookup(hash) == STATUS.Verified, "Access denied");

  // Feature must exist
  const fid = disclose(feature_id);
  assert(features.member(fid), "Feature does not exist");
  const f = features.lookup(fid);

  // Age check via ZK witness
  const ageOk = disclose(check_age_feature(cert, f.min_age));
  assert(ageOk, "Age verification failed");

  // Payment check: if feature has a price, ensure the user pays exactly that
  if (f.price > 0) {
    const paidCoin = disclose(payment);
    assert(paidCoin.value == f.price, "Incorrect payment amount");
    assert (paidCoin.color == f.coin_type, "Incorrect coin type");
    
    // Transfer the token/coin to the contract (or admin)
    receive(paidCoin); // contract receives the payment

    // Update the protocol's TVL with the new coin 
    // check if already in feature_balances
    if (!feature_balances.member(fid)) {
        feature_balances.insert(fid, 0 as Uint<128>);
    }
    feature_balances.insert(
        fid, 
        (feature_balances.lookup(fid) + paidCoin.value) as Uint<128>
    );

    //    const coinToInsert = protocolTVL.member(paidCoin.color) ? 
    // mergeCoinImmediate(protocolTVL.lookup(paidCoin.color), paidCoin) :
    // paidCoin;

    // protocolTVL.insertCoin(
    //     paidCoin.color, 
    //     coinToInsert, 
    //     right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
    // );
  }

  // Record anonymous access (nullifier)
  const accessNull = disclose(gen_access_nullifier(cert, fid));
  if (!access_nullifiers.member(accessNull)) {
    access_nullifiers.insert(accessNull, true);
  }
}

export circuit withdrawFunds(feature_id: Uint<64>,_coinType: Bytes<32>): [] {
    const fid = disclose(feature_id);
    assert(features.member(fid), "Feature does not exist");
    const f = features.lookup(fid);
    assert(f.creator == ownPublicKey(), "Only feature creator can withdraw");
    const coinType = disclose(f.coin_type);
    const sendResult = send(
        protocolTVL.lookup(coinType), 
        left<ZswapCoinPublicKey, ContractAddress>(f.creator),
        disclose(feature_balances.lookup(fid))
    );
    feature_balances.remove(fid);
}


// ─────────────────────────────────────────────────────────────────────────────
// Voting on features (anonymous, one vote per user per feature)
// ─────────────────────────────────────────────────────────────────────────────

// like = true -> upvote, like = false -> downvote
export circuit vote_on_feature(
  cert: Certificate,
  feature_id: Uint<64>,
  like: Boolean,
  vote_salt: Bytes<32>
): [] {
  // Feature must exist
  const fid = disclose(feature_id);
  assert(features.member(fid), "Feature does not exist");

  // Ensure the cert is still verified (not revoked)
  const hash = disclose(cert_hash(cert));
  assert(registered_hashes.member(hash), "Certificate not registered");
  assert(registered_hashes.lookup(hash) == STATUS.Verified, "Certificate not verified");

  // Ensure the user actually accessed this feature (anonymous check)
  const accessNull = disclose(gen_access_nullifier(cert, fid));
  assert(access_nullifiers.member(accessNull), "Must access feature before voting");

  // Prevent double-voting: anonymous per-(user, feature_id) nullifier
  const voteNull = disclose(gen_vote_nullifier(cert, fid, disclose(vote_salt)));
  assert(!vote_nullifiers.member(voteNull), "Already voted for this feature");
  vote_nullifiers.insert(voteNull, true);

  // Update public aggregate tally only
  assert(feature_vote_tallies.member(fid), "Vote tally not initialized");
  const tally = feature_vote_tallies.lookup(fid);

  if (disclose(like)) {
    feature_vote_tallies.insert(
      fid,
      VoteTally{ ...tally, up: (tally.up + 1) as Uint<64> }
    );
  } else {
    feature_vote_tallies.insert(
      fid,
      VoteTally{ ...tally, down: (tally.down + 1) as Uint<64> }
    );
  }
}

// Read-only helper to fetch current vote totals
export circuit get_feature_votes(feature_id: Uint<64>): VoteTally {
  const fid = disclose(feature_id);
  assert(feature_vote_tallies.member(fid), "Feature does not exist");
  return feature_vote_tallies.lookup(fid);
}
